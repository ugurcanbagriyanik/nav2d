{"version":3,"file":"nav2d.min.js","mappings":"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","sources":["webpack://nav2d/webpack/universalModuleDefinition","webpack://nav2d/external umd {\"root\":\"earcut\",\"amd\":\"earcut\",\"commonjs2\":\"earcut\",\"commonjs\":\"earcut\"}","webpack://nav2d/external umd {\"root\":\"point-in-polygon\",\"amd\":\"point-in-polygon\",\"commonjs2\":\"point-in-polygon\",\"commonjs\":\"point-in-polygon\"}","webpack://nav2d/external umd {\"root\":\"simple-quadtree\",\"amd\":\"simple-quadtree\",\"commonjs2\":\"simple-quadtree\",\"commonjs\":\"simple-quadtree\"}","webpack://nav2d/external umd {\"root\":\"uuid\",\"amd\":\"uuid\",\"commonjs2\":\"uuid\",\"commonjs\":\"uuid\"}","webpack://nav2d/webpack/bootstrap","webpack://nav2d/webpack/runtime/define property getters","webpack://nav2d/webpack/runtime/hasOwnProperty shorthand","webpack://nav2d/webpack/runtime/make namespace object","webpack://nav2d/./src/math.js","webpack://nav2d/./node_modules/tinyqueue/index.js","webpack://nav2d/./src/navmesh.js","webpack://nav2d/./src/nav2d.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"uuid\"), require(\"point-in-polygon\"), require(\"earcut\"), require(\"simple-quadtree\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"uuid\", \"point-in-polygon\", \"earcut\", \"simple-quadtree\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"nav2d\"] = factory(require(\"uuid\"), require(\"point-in-polygon\"), require(\"earcut\"), require(\"simple-quadtree\"));\n\telse\n\t\troot[\"nav2d\"] = factory(root[\"uuid\"], root[\"point-in-polygon\"], root[\"earcut\"], root[\"simple-quadtree\"]);\n})((typeof self !== 'undefined' ? self : this), (__WEBPACK_EXTERNAL_MODULE__120__, __WEBPACK_EXTERNAL_MODULE__260__, __WEBPACK_EXTERNAL_MODULE__238__, __WEBPACK_EXTERNAL_MODULE__154__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__238__;","module.exports = __WEBPACK_EXTERNAL_MODULE__260__;","module.exports = __WEBPACK_EXTERNAL_MODULE__154__;","module.exports = __WEBPACK_EXTERNAL_MODULE__120__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export const EPS = 1e-8;\r\n\r\nexport class Vector {\r\n    constructor(x, y) {\r\n        if (typeof x !== \"number\" || typeof y !== \"number\") {\r\n            throw new Error(\"Vector components must be numbers.\");\r\n        }\r\n\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    _normOther(other) {\r\n        if (typeof other == \"number\") {\r\n            return new Vector(other, other);\r\n        }\r\n        return other;\r\n    }\r\n\r\n    add(other) {\r\n        other = this._normOther(other);\r\n        return new Vector(this.x + other.x, this.y + other.y);\r\n    }\r\n\r\n    sub(other) {\r\n        other = this._normOther(other);\r\n        return new Vector(this.x - other.x, this.y - other.y);\r\n    }\r\n\r\n    mul(other) {\r\n        other = this._normOther(other);\r\n        return new Vector(this.x * other.x, this.y * other.y);\r\n    }\r\n\r\n    div(other) {\r\n        other = this._normOther(other);\r\n        return new Vector(this.x / other.x, this.y / other.y);\r\n    }\r\n\r\n    length() {\r\n        return Math.sqrt(this.x * this.x + this.y * this.y);\r\n    }\r\n\r\n    equals(other) {\r\n        return isclose(this.x, other.x) && isclose(this.y, other.y);\r\n    }\r\n\r\n    angle(other) {\r\n        return Math.acos(\r\n            clip(-1, 1, dot(this, other) / (this.length() * other.length()))\r\n        );\r\n    }\r\n\r\n    counterclockwiseAngle(other) {\r\n        const angle = this.angle(other);\r\n        return cross(this, other) >= 0 ? angle : 2 * Math.PI - angle;\r\n    }\r\n\r\n    toString() {\r\n        return `{ x: ${this.x}, y: ${this.y} }`;\r\n    }\r\n}\r\n\r\nexport function dot(a, b) {\r\n    return a.x * b.x + a.y * b.y;\r\n}\r\n\r\nexport function cross(a, b) {\r\n    return a.x * b.y - a.y * b.x;\r\n}\r\n\r\nexport function isclose(a, b, eps = EPS) {\r\n    return a > b - eps && a < b + eps;\r\n}\r\n\r\nexport function clip(a, b, v) {\r\n    if (v < a) return a;\r\n    if (v > b) return b;\r\n    return v;\r\n}\r\n","\nexport default class TinyQueue {\n    constructor(data = [], compare = defaultCompare) {\n        this.data = data;\n        this.length = this.data.length;\n        this.compare = compare;\n\n        if (this.length > 0) {\n            for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n        }\n    }\n\n    push(item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    }\n\n    pop() {\n        if (this.length === 0) return undefined;\n\n        const top = this.data[0];\n        const bottom = this.data.pop();\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = bottom;\n            this._down(0);\n        }\n\n        return top;\n    }\n\n    peek() {\n        return this.data[0];\n    }\n\n    _up(pos) {\n        const {data, compare} = this;\n        const item = data[pos];\n\n        while (pos > 0) {\n            const parent = (pos - 1) >> 1;\n            const current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    }\n\n    _down(pos) {\n        const {data, compare} = this;\n        const halfLength = this.length >> 1;\n        const item = data[pos];\n\n        while (pos < halfLength) {\n            let left = (pos << 1) + 1;\n            let best = data[left];\n            const right = left + 1;\n\n            if (right < this.length && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","import { v4 } from \"uuid\";\r\nimport inside from \"point-in-polygon\";\r\nimport earcut from \"earcut\";\r\nimport QuadTree from \"simple-quadtree\";\r\nimport TinyQueue from \"tinyqueue\";\r\n\r\nimport { cross, dot, isclose, Vector } from \"./math.js\";\r\n\r\nfunction _normalizePoint(point) {\r\n    if (point instanceof Array) {\r\n        return new Vector(...point);\r\n    } else if (point instanceof Vector) {\r\n        return point;\r\n    } else if (point.hasOwnProperty(\"x\") && point.hasOwnProperty(\"y\")) {\r\n        return new Vector(point.x, point.y);\r\n    }\r\n}\r\n\r\nexport class Edge {\r\n    constructor(p1, p2) {\r\n        this._uuid = v4();\r\n        this.p1 = _normalizePoint(p1);\r\n        this.p2 = _normalizePoint(p2);\r\n    }\r\n\r\n    length() {\r\n        return this.p1.sub(this.p2).length();\r\n    }\r\n\r\n    direction() {\r\n        return this.p1.sub(this.p2);\r\n    }\r\n\r\n    onEdge(point) {\r\n        point = _normalizePoint(point);\r\n        const pointVec = this.p1.sub(point);\r\n\r\n        if (!this.parallel(pointVec)) return false;\r\n\r\n        // test that it's not only collinear, but falls between p1 and p2\r\n        const direction = this.direction();\r\n        const len = this.length();\r\n        const component = dot(direction, pointVec) / (len * len);\r\n        return component >= 0 && component <= 1;\r\n    }\r\n\r\n    parallel(other) {\r\n        const otherDirection =\r\n            other instanceof Vector ? other : other.p1.sub(other.p2);\r\n        return isclose(cross(this.direction(), otherDirection), 0);\r\n    }\r\n\r\n    collinear(other) {\r\n        const direction = this.direction();\r\n        const otherVec1 = this.p1.sub(other.p1);\r\n        const otherVec2 = this.p1.sub(other.p2);\r\n        return (\r\n            isclose(cross(direction, otherVec1), 0) &&\r\n            isclose(cross(direction, otherVec2), 0)\r\n        );\r\n    }\r\n\r\n    overlap(other) {\r\n        if (!this.collinear(other)) {\r\n            throw new Error(\r\n                \"Cannot compute overlap of two non-collinear edges.\"\r\n            );\r\n        }\r\n\r\n        let endpoints = [];\r\n\r\n        if (this.onEdge(other.p1)) endpoints.push(other.p1);\r\n        if (this.onEdge(other.p2)) endpoints.push(other.p2);\r\n        if (other.onEdge(this.p1)) endpoints.push(this.p1);\r\n        if (other.onEdge(this.p2)) endpoints.push(this.p2);\r\n\r\n        // enpoints can also be the an array with twice the same point,\r\n        // which is fine as it yields a zero-length edge\r\n        if (endpoints.length > 2) {\r\n            endpoints = endpoints.filter(\r\n                (p, i) => endpoints.findIndex((op) => op.equals(p)) === i\r\n            );\r\n        }\r\n\r\n        if (!endpoints.length) {\r\n            return null;\r\n        } else if (endpoints.length == 1) {\r\n            endpoints = [endpoints[0], endpoints[0]];\r\n        }\r\n\r\n        return new Edge(...endpoints);\r\n    }\r\n\r\n    equals(other) {\r\n        return (\r\n            (this.p1.equals(other.p1) && this.p2.equals(other.p2)) ||\r\n            (this.p1.equals(other.p2) && this.p2.equals(other.p1))\r\n        );\r\n    }\r\n}\r\n\r\nexport class Polygon {\r\n    constructor(points) {\r\n        this._uuid = v4();\r\n        this.points = points.map(_normalizePoint);\r\n        this.bounds = this._computeBounds();\r\n    }\r\n\r\n    _computeBounds() {\r\n        return this.points.reduce(\r\n            (a, p) => [\r\n                Math.min(p.x, a[0]),\r\n                Math.min(p.y, a[1]),\r\n                Math.max(p.x, a[2]),\r\n                Math.max(p.y, a[3]),\r\n            ],\r\n            [Infinity, Infinity, -Infinity, -Infinity]\r\n        );\r\n    }\r\n\r\n    edges() {\r\n        return this.points.map(\r\n            (point, i) =>\r\n                new Edge(\r\n                    i == 0\r\n                        ? this.points[this.points.length - 1]\r\n                        : this.points[i - 1],\r\n                    point\r\n                )\r\n        );\r\n    }\r\n\r\n    centroid() {\r\n        return this.points\r\n            .reduce((acc, point) => acc.add(point), new Vector(0, 0))\r\n            .div(this.points.length);\r\n    }\r\n\r\n    centroidDistance(other) {\r\n        const centroidVector = this.centroid().sub(other.centroid());\r\n        return centroidVector.length();\r\n    }\r\n\r\n    contains(point) {\r\n        point = _normalizePoint(point);\r\n        const polyPoints = this.points.map(this._toPointArray);\r\n        return (\r\n            inside(this._toPointArray(point), polyPoints) ||\r\n            !!this.onEdge(point)\r\n        );\r\n    }\r\n\r\n    _toPointArray(point) {\r\n        return [point.x, point.y];\r\n    }\r\n\r\n    onEdge(point) {\r\n        point = _normalizePoint(point);\r\n        for (const edge of this.edges()) {\r\n            if (edge.onEdge(point)) return edge;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    touches(otherEdge) {\r\n        for (const edge of this.edges()) {\r\n            if (\r\n                (edge.onEdge(otherEdge.p1) || edge.onEdge(otherEdge.p2)) &&\r\n                edge.collinear(otherEdge)\r\n            ) {\r\n                return edge;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    boundsSize() {\r\n        const [minx, miny, maxx, maxy] = this.bounds;\r\n        return { x: minx, y: miny, w: maxx - minx, h: maxy - miny };\r\n    }\r\n\r\n    getClosestPointTo(point) {\r\n\r\n        // Normalize the input point\r\n        point = _normalizePoint(point);\r\n\r\n        // Initialize variables for tracking the closest point and its distance\r\n        let closestPoint = null;\r\n        let shortestDistance = Infinity;\r\n\r\n        // Iterate through all edges of the polygon\r\n        for (const edge of this.edges()) {\r\n            // Implementing closestPoint method for the edge\r\n            const edgeDirection = edge.direction();\r\n            const edgeLengthSquared = edgeDirection.length() ** 2;\r\n\r\n            if (edgeLengthSquared === 0) {\r\n                // Edge is a point\r\n                const candidatePoint = edge.p1;\r\n                const distance = point.sub(candidatePoint).length();\r\n\r\n                if (distance < shortestDistance) {\r\n                    shortestDistance = distance;\r\n                    closestPoint = candidatePoint;\r\n                }\r\n                continue;\r\n            }\r\n\r\n            const t = Math.max(\r\n                0,\r\n                Math.min(\r\n                    1,\r\n                    dot(point.sub(edge.p1), edgeDirection) / edgeLengthSquared,\r\n                ),\r\n            );\r\n\r\n            const candidatePoint = edge.p1.add(edgeDirection.mul(t));\r\n\r\n            // Calculate the distance from the input point to the candidate point\r\n            const distance = point.sub(candidatePoint).length();\r\n\r\n            // If this distance is shorter than the currently tracked shortest distance, update\r\n            if (distance < shortestDistance) {\r\n                shortestDistance = distance;\r\n                closestPoint = candidatePoint;\r\n            }\r\n        }\r\n\r\n        // Return the closest point found\r\n        return closestPoint;\r\n    }\r\n}\r\n\r\nexport class NavMesh {\r\n    constructor(polygons, options = {}, heuristicFunc = null) {\r\n        this._uuid = v4();\r\n\r\n        options = {\r\n            triangulate: true,\r\n            pointQuerySize: 0.01,\r\n            ...options, // Yes, this works even if options is null or a function!\r\n        };\r\n        // The following ifs provide backward compatibility\r\n        if (typeof options === 'function') {\r\n            console.warn(\r\n                \"DEPRECATION WARNING: nav2d now uses the signature \"\r\n                + \"NavMesh(polygons, options = { costFunc: ..., heuristicFunc: ... }) \"\r\n                + \"but you are using the old signature NavMesh(polygons, costFunc, heuristicFunc). \"\r\n                + \"Please update, the code will break in a future release.\"\r\n            );\r\n            options.costFunc = options;\r\n        }\r\n        if (typeof heuristicFunc === 'function') {\r\n            console.warn(\r\n                \"DEPRECATION WARNING: nav2d now uses the signature \"\r\n                + \"NavMesh(polygons, options = { costFunc: ..., heuristicFunc: ... }) \"\r\n                + \"but you are using the old signature NavMesh(polygons, costFunc, heuristicFunc). \"\r\n                + \"Please update, the code will break in a future release.\"\r\n            );\r\n            options.heuristicFunc = heuristicFunc;\r\n        }\r\n        \r\n        this.costFunc = options.costFunc || ((a, b) => this._computeDistance(a, b));\r\n        this.heuristicFunc = options.heuristicFunc || ((a, b) => this._computeDistance(a, b));\r\n\r\n        if (options.triangulate) {\r\n            polygons = this._triangulate(polygons);\r\n        }\r\n        this.polygons = polygons.map((points) => new Polygon(points));\r\n\r\n        // This will be used to check point collision with\r\n        // triangles. This should be much smaller that the typical\r\n        // size of your mesh triangles to avoid checking too many\r\n        // triangles for collision.\r\n        this.pointQuerySize = options.pointQuerySize;\r\n\r\n        this._buildQuadtree();\r\n        this._buildNeighbors();\r\n    }\r\n\r\n    _triangulate(polygons) {\r\n        const triangles = [];\r\n        for (const poly of polygons) {\r\n            const trianglesIndices = earcut(this._flatten(poly));\r\n            for (let i = 0; i < trianglesIndices.length / 3; i++) {\r\n                const indices = trianglesIndices.slice(i * 3, i * 3 + 3);\r\n                triangles.push(indices.map((j) => poly[j]));\r\n            }\r\n        }\r\n        return triangles;\r\n    }\r\n\r\n    _flatten(points) {\r\n        const flatPoints = [];\r\n        for (const point of points) {\r\n            if (point instanceof Array) {\r\n                flatPoints.push(...point);\r\n            } else {\r\n                flatPoints.push(point.x, point.y);\r\n            }\r\n        }\r\n        return flatPoints;\r\n    }\r\n\r\n    _buildQuadtree() {\r\n        // Use quad tree because the naive approach of iterating\r\n        // with two nested for loops over the polygons has performance\r\n        // n*lon(n), which for a 30x30 grid already takes a minute.\r\n        // This thing, for the same grid, takes 1 second, and scales linearly.\r\n        this.qt = QuadTree(-Infinity, -Infinity, Infinity, Infinity);\r\n        for (const poly of this.polygons) {\r\n            this.qt.put({\r\n                ...poly.boundsSize(),\r\n                polygon: poly,\r\n            });\r\n        }\r\n    }\r\n\r\n    _buildNeighbors() {\r\n        this.polygons.forEach((polygon) => (polygon.neighbors = {}));\r\n\r\n        for (let i = 0; i < this.polygons.length; i++) {\r\n            const poly1 = this.polygons[i];\r\n\r\n            for (const poly2wrap of this.qt.get(poly1.boundsSize())) {\r\n                const poly2 = poly2wrap.polygon;\r\n\r\n                if (poly1 === poly2) continue;\r\n                if (poly1.neighbors.hasOwnProperty(poly2._uuid)) continue;\r\n\r\n                const portal = this._computePortal(poly1, poly2);\r\n                if (portal !== null && portal.length() > 0) {\r\n                    // Ensure that portal points are given in left-to-right order, viewed from the centroid of the polygon\r\n                    let [p1, p2] = this._orderLeftRight(\r\n                        poly1.centroid(),\r\n                        portal.p1,\r\n                        portal.p2\r\n                    );\r\n                    poly1.neighbors[poly2._uuid] = {\r\n                        polygon: poly2,\r\n                        portal: new Edge(p1, p2),\r\n                    };\r\n                    poly2.neighbors[poly1._uuid] = {\r\n                        polygon: poly1,\r\n                        portal: new Edge(p2, p1),\r\n                    };\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    _computePortal(poly1, poly2) {\r\n        for (const edge1 of poly1.edges()) {\r\n            const edge2 = poly2.touches(edge1);\r\n            if (edge2 !== null) {\r\n                return edge1.overlap(edge2);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    findPath(from, to) {\r\n        from = _normalizePoint(from);\r\n        to = _normalizePoint(to);\r\n\r\n        let fromPoly = this._findContainingPolygon(from);\r\n        let toPoly = this._findContainingPolygon(to);\r\n\r\n        if (fromPoly === null){\r\n            from = this.findClosestPointInPolygons(from);\r\n        }\r\n\r\n        if (toPoly === null){\r\n            to = this.findClosestPointInPolygons(to);\r\n        }\r\n\r\n        const path = this._findPath(from, to);\r\n        return path && this._funnel(from, to, path);\r\n    }\r\n\r\n    findClosestPointInPolygons(point) {\r\n\r\n        let closestPoint = null;\r\n        let minDistance = Infinity;\r\n\r\n        for (const poly of this.polygons) {\r\n            let candidatePoint = poly.getClosestPointTo(point);\r\n\r\n            const distance = point.sub(candidatePoint).length();\r\n            if (distance < minDistance && this._findContainingPolygon(candidatePoint)!==null && distance!==0) {\r\n                minDistance = distance;\r\n                closestPoint = candidatePoint;\r\n            }\r\n        }\r\n        return closestPoint;\r\n    }\r\n\r\n    _findPath(from, to) {\r\n        // This is the A* algorithm\r\n        let fromPoly = this._findContainingPolygon(from);\r\n        let toPoly = this._findContainingPolygon(to);\r\n\r\n        if (fromPoly === null){\r\n            from = this.findClosestPointInPolygons(from);\r\n            fromPoly = this._findContainingPolygon(from);\r\n        }\r\n\r\n        if (toPoly === null){\r\n            to = this.findClosestPointInPolygons(to);\r\n            toPoly = this._findContainingPolygon(to);\r\n        }\r\n\r\n        const frontier = new TinyQueue(\r\n            [{ cost: 0, polygon: fromPoly }],\r\n            (a, b) => a.cost - b.cost\r\n        );\r\n        const cameFrom = { [fromPoly._uuid]: null };\r\n        const cost = { [fromPoly._uuid]: 0 };\r\n\r\n        while (frontier.length) {\r\n            const current = frontier.pop().polygon;\r\n\r\n            if (current._uuid === toPoly._uuid) {\r\n                break;\r\n            }\r\n\r\n            for (const { polygon: next } of Object.values(current.neighbors)) {\r\n                const nextCost =\r\n                    cost[current._uuid] + this._computeCost(current, next);\r\n\r\n                if (\r\n                    // node not yet visited\r\n                    !cost.hasOwnProperty(next._uuid) ||\r\n                    // this path to node has lower cost\r\n                    nextCost < cost[next._uuid]\r\n                ) {\r\n                    frontier.push({\r\n                        cost: nextCost + this._heuristic(next, toPoly),\r\n                        polygon: next,\r\n                    });\r\n                    cost[next._uuid] = nextCost;\r\n                    cameFrom[next._uuid] = current;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this._reconstructPath(toPoly, cameFrom);\r\n    }\r\n\r\n    _computeDistance(a, b) {\r\n        return a.centroidDistance(b);\r\n    }\r\n\r\n    _computeCost(a, b) {\r\n        const portal = a.neighbors[b._uuid].portal;\r\n        return this.costFunc(a, b, portal);\r\n    }\r\n\r\n    _heuristic(poly, to) {\r\n        if (poly._uuid == to._uuid) return 0;\r\n        return this.heuristicFunc(poly, to);\r\n    }\r\n\r\n    _findContainingPolygon(point) {\r\n        const halfQuerySize = this.pointQuerySize / 2;\r\n        const bounds = {\r\n            x: point.x - halfQuerySize,\r\n            y: point.y - halfQuerySize,\r\n            w: this.pointQuerySize,\r\n            h: this.pointQuerySize,\r\n        };\r\n        for (const poly of this.qt.get(bounds)) {\r\n            if (poly.polygon.contains(point)) return poly.polygon;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    _reconstructPath(to, cameFrom) {\r\n        if (!cameFrom.hasOwnProperty(to._uuid)) {\r\n            // Disconnected\r\n            return null;\r\n        }\r\n\r\n        let current = to;\r\n\r\n        const path = [];\r\n        while (current !== null) {\r\n            path.push(current);\r\n            current = cameFrom[current._uuid];\r\n        }\r\n\r\n        return path.reverse();\r\n    }\r\n\r\n    /** Funnel algorithm, following https://medium.com/@reza.teshnizi/the-funnel-algorithm-explained-visually-41e374172d2d */\r\n    _funnel(from, to, path) {\r\n        if (path.length === 0) {\r\n            throw new Error(\"Path cannot be empty.\");\r\n        } else if (path.length === 1) {\r\n            return [from, to];\r\n        }\r\n\r\n        const tail = [from];\r\n        const left = [];\r\n        const right = [];\r\n\r\n        // Initialize funnel\r\n        const initialPortal = path[0].neighbors[path[1]._uuid].portal;\r\n        left.push(initialPortal.p1);\r\n        right.push(initialPortal.p2);\r\n\r\n        // Iterate over portals\r\n        for (let i = 1; i < path.length - 1; i++) {\r\n            const poly = path[i];\r\n            const nextPoly = path[i + 1];\r\n            const portal = poly.neighbors[nextPoly._uuid].portal;\r\n            // The portal end points are in left-to-right order, viewed from the inside of the polygon.\r\n            this._extendFunnel(tail, left, right, portal.p1, portal.p2);\r\n        }\r\n\r\n        // Close funnel to endpoint\r\n        this._extendFunnel(tail, left, right, to, to);\r\n\r\n        return tail;\r\n    }\r\n\r\n    _extendFunnel(tail, left, right, leftPoint, rightPoint) {\r\n        // Extend funnel on the left\r\n        this._extendFunnelSide(tail, left, right, true, leftPoint);\r\n        // Extend funnel on the right\r\n        this._extendFunnelSide(tail, left, right, false, rightPoint);\r\n    }\r\n\r\n    _extendFunnelSide(tail, left, right, extendLeft, newPoint) {\r\n        const apex = tail[tail.length - 1];\r\n        // We pretend to be in the `expandLeft` case here. Otherwise flip.\r\n        if (!extendLeft) {\r\n            [left, right] = [right, left];\r\n        }\r\n\r\n        // If `newPoint` is the end point of the left side of the funnel, skip it.\r\n        const lastLeft =\r\n            left.length === 0 ? tail[tail.length - 1] : left[left.length - 1];\r\n        if (newPoint.equals(lastLeft)) {\r\n            return;\r\n        }\r\n\r\n        // Determine how far to shrink the funnel\r\n        let j = this._findFirstLeftOfPoint(\r\n            apex,\r\n            left,\r\n            newPoint,\r\n            true,\r\n            !extendLeft\r\n        );\r\n        // All points in `left` with index `< j` are right of `newPoint` and\r\n        // all points in `left` with index `>= j` are left of or at the same angle as `newPoint`.\r\n        left.length = j; // Shrink funnel if `j < left.length`\r\n        left.push(newPoint);\r\n        if (j === 0) {\r\n            // If the funnel shrunk all the way on the left, it might collapse to the right.\r\n            // Determine how far it needs to collapse\r\n            let k = this._findFirstLeftOfPoint(\r\n                apex,\r\n                right,\r\n                newPoint,\r\n                false,\r\n                extendLeft\r\n            );\r\n            // All points in `right` with index `< k` are left of or at the same angle as `newPoint` and\r\n            // all points in `right` with index `>= k` are right of `newPoint`.\r\n            tail.push(...right.splice(0, k)); // Collapse funnel if `k > 0`\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given an array `arr` of points, find the index of the first one that is\r\n     * on the left side of a given point `p`, viewed from `origin`. If no such\r\n     * point exists, the length of the list is returned.\r\n     *\r\n     * If `flip` is true, find the first that is on the right side instead.\r\n     *\r\n     * If `acceptColinear` is true, the returned point may also be colinear.\r\n     */\r\n    _findFirstLeftOfPoint(origin, arr, p, acceptColinear, flip) {\r\n        let i;\r\n        for (i = 0; i < arr.length; i++) {\r\n            const found = flip\r\n                ? this._isInLeftRightOrder(origin, p, arr[i], acceptColinear)\r\n                : this._isInLeftRightOrder(origin, arr[i], p, acceptColinear);\r\n            if (found) return i;\r\n        }\r\n        return i;\r\n    }\r\n\r\n    /**\r\n     * Are the points `p1` and `p2` in left-to-right order, viewed from `origin`?\r\n     * If points are colinear, the value of `acceptColinear` is returned.\r\n     */\r\n    _isInLeftRightOrder(origin, p1, p2, acceptColinear = false) {\r\n        const vec1 = p1.sub(origin);\r\n        const vec2 = p2.sub(origin);\r\n        const c = cross(vec1, vec2);\r\n        return acceptColinear ? c <= 0 : c < 0;\r\n    }\r\n\r\n    /** Returns the points `p1` and `p2` in left-to-right order, viewed from `origin`. */\r\n    _orderLeftRight(origin, p1, p2) {\r\n        if (this._isInLeftRightOrder(origin, p1, p2)) {\r\n            return [p1, p2];\r\n        } else {\r\n            return [p2, p1];\r\n        }\r\n    }\r\n}\r\n","import { Vector, isclose, clip, dot, cross } from \"./math.js\";\r\nimport { Edge, Polygon, NavMesh } from \"./navmesh.js\";\r\n\r\nconst Point = Vector;\r\n\r\nexport { Point, Vector, isclose, clip, dot, cross, Edge, Polygon, NavMesh };\r\n"],"names":["root","factory","exports","module","require","define","amd","self","this","__WEBPACK_EXTERNAL_MODULE__120__","__WEBPACK_EXTERNAL_MODULE__260__","__WEBPACK_EXTERNAL_MODULE__238__","__WEBPACK_EXTERNAL_MODULE__154__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","EPS","Vector","x","y","_classCallCheck","Error","other","_normOther","Math","sqrt","isclose","acos","clip","dot","length","angle","cross","PI","concat","a","b","eps","arguments","v","TinyQueue","constructor","data","compare","defaultCompare","i","_down","push","item","_up","pop","top","bottom","peek","pos","parent","current","halfLength","left","best","right","_normalizePoint","point","Array","_construct","_toConsumableArray","Edge","p1","p2","_uuid","v4","_createClass","sub","pointVec","parallel","direction","len","component","otherDirection","otherVec1","otherVec2","collinear","endpoints","onEdge","filter","p","findIndex","op","equals","Polygon","points","map","bounds","_computeBounds","reduce","min","max","Infinity","_this","acc","add","div","centroid","polyPoints","_toPointArray","inside","_step","_iterator","_createForOfIteratorHelper","edges","s","n","done","edge","err","e","f","otherEdge","_step2","_iterator2","_this$bounds","_slicedToArray","minx","miny","w","h","_step3","closestPoint","shortestDistance","_iterator3","edgeDirection","edgeLengthSquared","pow","t","candidatePoint","mul","distance","NavMesh","polygons","_this2","options","heuristicFunc","_objectSpread","triangulate","pointQuerySize","console","warn","costFunc","_computeDistance","_triangulate","_buildQuadtree","_buildNeighbors","_step4","_this3","triangles","_iterator4","_loop","poly","trianglesIndices","earcut","_flatten","indices","slice","j","_step5","flatPoints","_iterator5","apply","qt","QuadTree","_step6","_iterator6","put","boundsSize","polygon","forEach","neighbors","_step7","poly1","_iterator7","poly2","portal","_computePortal","_this$_orderLeftRight2","_orderLeftRight","_step8","_iterator8","edge1","edge2","touches","overlap","from","to","fromPoly","_findContainingPolygon","toPoly","findClosestPointInPolygons","path","_findPath","_funnel","_step9","minDistance","_iterator9","getClosestPointTo","frontier","cost","cameFrom","_defineProperty","_i","_Object$values","values","next","nextCost","_computeCost","_heuristic","_reconstructPath","centroidDistance","_step10","halfQuerySize","_iterator10","contains","reverse","tail","initialPortal","nextPoly","_extendFunnel","leftPoint","rightPoint","_extendFunnelSide","extendLeft","newPoint","apex","_ref","lastLeft","_findFirstLeftOfPoint","k","splice","origin","arr","acceptColinear","flip","_isInLeftRightOrder","c","Point"],"sourceRoot":""}